import asyncio
import os
import logging
from typing import List, Dict, Any, Literal

import dotenv
from fastmcp import FastMCP
from pydantic import BaseModel, Field, ConfigDict
from rapidfuzz import fuzz
from neo4j import GraphDatabase
from starlette.middleware import Middleware
from starlette.middleware.cors import CORSMiddleware
from typing import Optional


# =========================
# ЗАГРУЗКА ENV
# =========================

load_status = dotenv.load_dotenv(
    "/Users/maksi/Desktop/работа/mcp/онтология/mcp-serverNEO4J/Neo4j-aa1242b2-Created-2025-11-27.txt"
)
if not load_status:
    raise RuntimeError("Environment variables not loaded.")

URI = os.getenv("NEO4J_URI")
AUTH = (os.getenv("NEO4J_USERNAME"), os.getenv("NEO4J_PASSWORD"))

# =========================
# ЛОГИРОВАНИЕ
# =========================
logger = logging.getLogger("neo4j_mcp_server")
logger.setLevel(logging.INFO)
console = logging.StreamHandler()
console.setLevel(logging.INFO)
logger.addHandler(console)

# =========================
# ПОДКЛЮЧЕНИЕ NEO4J
# =========================
driver = GraphDatabase.driver(URI, auth=AUTH)
with driver.session() as session:
    session.run("RETURN 1")
logger.info("Connected to Neo4j")

# =========================
# MCP
# =========================
mcp = FastMCP("neo4j-mcp")
logger.info("Neo4j MCP server created")

# =========================
# MODELS
# =========================
class SearchRequest(BaseModel):
    # КЛЮЧЕВОЕ: игнорируем все неизвестные поля (n8n / AI Agent)
    model_config = ConfigDict(extra="ignore")

    keywords: List[str] = Field(default_factory=list)
    limit: int = Field(default=10)

# =========================
# HELPERS
# =========================
def normalize_keywords(keywords: Any) -> List[str]:
    if keywords is None:
        return []
    if isinstance(keywords, str):
        return [k.strip() for k in keywords.split(",") if k.strip()]
    if isinstance(keywords, list):
        return [str(k).strip() for k in keywords if str(k).strip()]
    return [str(keywords).strip()] if str(keywords).strip() else []

def normalize_limit(limit: Any, default: int = 10) -> int:
    try:
        v = int(limit)
    except Exception:
        v = default
    return max(1, min(v, 50))

# =========================
# CORE LOGIC
# =========================
def fetch_graph_data() -> List[Dict[str, Any]]:
    query = """
    MATCH (c:commands)
    OPTIONAL MATCH (s:steps)-[:HAS_COMMAND]->(c)
    OPTIONAL MATCH (c)-[:HAS_PARAM]->(p:Params)
    RETURN 
        elementId(c) AS command_id,
        properties(c) AS command_props,
        COALESCE(c.description, '') AS command_desc,
        COALESCE(s.description, '') AS step_desc,
        COALESCE(p.Description, '') AS param_desc,
        COALESCE(c.Tags, []) AS command_tags,
        COALESCE(s.Tags, []) AS step_tags,
        COALESCE(p.Tags, []) AS param_tags
    """

    rows = []
    with driver.session() as session:
        result = session.run(query)
        for record in result:
            text_content = " ".join([
                record["command_desc"],
                record["step_desc"],
                record["param_desc"],
                *record["command_tags"],
                *record["step_tags"],
                *record["param_tags"],
            ])

            rows.append({
                "command_id": record["command_id"],
                "command_props": record["command_props"],   # <-- ВСЕ Properties узла :commands
                "text": text_content
            })
    return rows

def score_commands(rows: List[Dict[str, Any]], keywords: List[str]) -> List[Dict[str, Any]]:
    scored: Dict[str, Dict[str, Any]] = {}

    for row in rows:
        cid = row["command_id"]
        props = row["command_props"]
        text = (row["text"] or "").lower()

        score = 0
        for kw in keywords:
            kw_lower = kw.lower()
            score += fuzz.partial_ratio(kw_lower, text)
            if kw_lower in text.split():
                score += 50

        if cid not in scored:
            scored[cid] = {"command_id": cid, "command_props": props, "score": 0}
        scored[cid]["score"] += score

    scored_list = list(scored.values())
    scored_list.sort(key=lambda x: x["score"], reverse=True)
    return scored_list


# =========================
# MCP TOOL
# =========================
@mcp.tool(description="Search commands in Neo4j by keywords or tags")
async def search_commands(
    # то, что реально нужно
    keywords: Optional[List[str]] = None,
    limit: int = 10,

    # лишние поля, которые шлёт n8n AI Agent / MCP Client (мы их просто игнорируем)
    request: Optional[str] = None,
    sessionId: Optional[str] = None,
    action: Optional[str] = None,
    chatInput: Optional[str] = None,
    toolCallId: Optional[str] = None,
    tool: Optional[str] = None,
):
    """
    Совместимо с fastmcp (без **kwargs) и устойчиво к n8n,
    который присылает служебные поля sessionId/action/chatInput/toolCallId.
    """

    # 1) Нормализуем keywords
    # Если keywords не пришли, но пришло поле request (например "дебит"), используем его как fallback.
    if not keywords or (isinstance(keywords, list) and len(keywords) == 0):
        if request:
            keywords = normalize_keywords(request)
        else:
            keywords = []

    keywords = normalize_keywords(keywords)

    # 2) Нормализуем limit
    limit = normalize_limit(limit, default=10)

    if not keywords:
        return {"keywords": [], "matched_commands": []}

    rows = await asyncio.to_thread(fetch_graph_data)
    scored = await asyncio.to_thread(score_commands, rows, keywords)
    top = scored[:limit]

    return {"keywords": keywords, "matched_commands": top}
# =========================
# SERVER START
# =========================
async def main(
    transport: Literal["http", "stdio", "sse"] = "http",
    host: str = "0.0.0.0",
    port: int = 3344,
    path: str = "/mcp/",
    allow_origins: List[str] = [],
):
    middleware = [
        Middleware(
            CORSMiddleware,
            allow_origins=allow_origins or ["*"],
            allow_methods=["GET", "POST"],
            allow_headers=["*"],
        )
    ]

    logger.info(f"Starting Neo4j MCP server on {host}:{port}{path} with transport {transport}")

    match transport:
        case "http":
            await mcp.run_http_async(
                host=host,
                port=port,
                path=path,
                middleware=middleware
            )
        case "stdio":
            await mcp.run_stdio_async()
        case "sse":
            await mcp.run_http_async(
                host=host,
                port=port,
                path=path,
                middleware=middleware,
                transport="sse"
            )
        case _:
            raise ValueError(f"Unsupported transport: {transport}")

if __name__ == "__main__":
    asyncio.run(main())
