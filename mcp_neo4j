import asyncio
import os
import logging
from typing import List, Dict, Any, Optional, Literal

from fastmcp import FastMCP
from neo4j import GraphDatabase
from rapidfuzz import fuzz
from starlette.middleware import Middleware
from starlette.middleware.cors import CORSMiddleware


# =========================
# LOGGING
# =========================
logger = logging.getLogger("neo4j_mcp_server")
logger.setLevel(logging.INFO)
handler = logging.StreamHandler()
handler.setLevel(logging.INFO)
logger.addHandler(handler)

# =========================
# MCP APP (must be top-level)
# =========================
mcp = FastMCP("neo4j-mcp")

# =========================
# NEO4J (lazy init - NO network on import)
# =========================
_driver = None

def get_driver():
    """
    Lazy driver init: called only when a tool is invoked.
    This avoids failing build/inspect in cloud environments.
    """
    global _driver
    if _driver is None:
        uri = os.getenv("NEO4J_URI")
        user = os.getenv("NEO4J_USER", "neo4j")
        password = os.getenv("NEO4J_PASSWORD")

        if not uri:
            raise RuntimeError("Missing env var: NEO4J_URI")
        if not password:
            raise RuntimeError("Missing env var: NEO4J_PASSWORD")

        _driver = GraphDatabase.driver(uri, auth=(user, password))
        logger.info("Neo4j driver initialized")
    return _driver


# =========================
# HELPERS
# =========================
def normalize_keywords(keywords: Any) -> List[str]:
    if keywords is None:
        return []
    if isinstance(keywords, str):
        return [k.strip() for k in keywords.split(",") if k.strip()]
    if isinstance(keywords, list):
        return [str(k).strip() for k in keywords if str(k).strip()]
    s = str(keywords).strip()
    return [s] if s else []

def normalize_limit(limit: Any, default: int = 10) -> int:
    try:
        v = int(limit)
    except Exception:
        v = default
    return max(1, min(v, 50))


# =========================
# CORE LOGIC
# =========================
def fetch_graph_data() -> List[Dict[str, Any]]:
    query = """
    MATCH (c:commands)
    OPTIONAL MATCH (s:steps)-[:HAS_COMMAND]->(c)
    OPTIONAL MATCH (c)-[:HAS_PARAM]->(p:Params)
    RETURN 
        elementId(c) AS command_id,
        properties(c) AS command_props,
        COALESCE(c.description, '') AS command_desc,
        COALESCE(s.description, '') AS step_desc,
        COALESCE(p.Description, '') AS param_desc,
        COALESCE(c.Tags, []) AS command_tags,
        COALESCE(s.Tags, []) AS step_tags,
        COALESCE(p.Tags, []) AS param_tags
    """

    driver = get_driver()
    rows: List[Dict[str, Any]] = []

    with driver.session() as session:
        result = session.run(query)
        for record in result:
            text_content = " ".join([
                record["command_desc"],
                record["step_desc"],
                record["param_desc"],
                *record["command_tags"],
                *record["step_tags"],
                *record["param_tags"],
            ])

            rows.append({
                "command_id": record["command_id"],
                "command_props": record["command_props"],
                "text": text_content,
            })

    return rows


def score_commands(rows: List[Dict[str, Any]], keywords: List[str]) -> List[Dict[str, Any]]:
    scored: Dict[str, Dict[str, Any]] = {}

    for row in rows:
        cid = row["command_id"]
        props = row["command_props"]
        text = (row["text"] or "").lower()

        score = 0
        for kw in keywords:
            kw_lower = kw.lower()
            score += fuzz.partial_ratio(kw_lower, text)
            if kw_lower in text.split():
                score += 50

        if cid not in scored:
            scored[cid] = {"command_id": cid, "command_props": props, "score": 0}
        scored[cid]["score"] += score

    scored_list = list(scored.values())
    scored_list.sort(key=lambda x: x["score"], reverse=True)
    return scored_list


# =========================
# MCP TOOL
# =========================
@mcp.tool(description="Search commands in Neo4j by keywords or tags")
async def search_commands(
    keywords: Optional[List[str]] = None,
    limit: int = 10,

    # extra fields that some clients (e.g. n8n) may send â€” we ignore
    request: Optional[str] = None,
    sessionId: Optional[str] = None,
    action: Optional[str] = None,
    chatInput: Optional[str] = None,
    toolCallId: Optional[str] = None,
    tool: Optional[str] = None,
):
    # fallback: if keywords missing, but request provided
    if not keywords:
        keywords = normalize_keywords(request) if request else []
    keywords = normalize_keywords(keywords)
    limit = normalize_limit(limit, default=10)

    if not keywords:
        return {"keywords": [], "matched_commands": []}

    rows = await asyncio.to_thread(fetch_graph_data)
    scored = await asyncio.to_thread(score_commands, rows, keywords)
    return {"keywords": keywords, "matched_commands": scored[:limit]}


# =========================
# SERVER START
# =========================
async def main(
    transport: Literal["http", "stdio", "sse"] = "http",
    host: str = "0.0.0.0",
    port: int = int(os.getenv("PORT", "8080")),
    path: str = "/mcp/",
    allow_origins: Optional[List[str]] = None,
):
    middleware = [
        Middleware(
            CORSMiddleware,
            allow_origins=allow_origins or ["*"],
            allow_methods=["GET", "POST"],
            allow_headers=["*"],
        )
    ]

    logger.info(f"Starting MCP on {host}:{port}{path} transport={transport}")

    if transport == "http":
        await mcp.run_http_async(host=host, port=port, path=path, middleware=middleware)
    elif transport == "stdio":
        await mcp.run_stdio_async()
    elif transport == "sse":
        await mcp.run_http_async(host=host, port=port, path=path, middleware=middleware, transport="sse")
    else:
        raise ValueError(f"Unsupported transport: {transport}")

if __name__ == "__main__":
    asyncio.run(main())
